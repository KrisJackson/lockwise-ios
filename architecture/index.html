<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Architecture - Firefox Lockwise for iOS</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Architecture";
    var mkdocs_page_input_path = "architecture.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Firefox Lockwise for iOS</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Introduction</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../release-notes/">Release Notes</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">How to Contribute</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../contributing/">Contributing</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../metrics/">Telemetry and Metrics</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Developer Guides</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../install/">Build and Install</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Architecture</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#firefox-lockwise-for-ios-architecture">Firefox Lockwise for iOS Architecture</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#rxswift">RxSwift</a></li>
        
            <li><a class="toctree-l4" href="#flux">Flux</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../updating_libraries/">Dependencies</a>
                </li>
                <li class="">
                    
    <a class="" href="../add-a-browser/">How to: add a browser</a>
                </li>
                <li class="">
                    
    <a class="" href="../new-ui/">How to: add a UI feature</a>
                </li>
                <li class="">
                    
    <a class="" href="../test-plan/">Test Plan</a>
                </li>
                <li class="">
                    
    <a class="" href="../releases/">Release Instructions</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Firefox Lockwise for iOS</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Developer Guides &raquo;</li>
        
      
    
    <li>Architecture</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/mozilla-lockwise/lockwise-ios/edit/master/docs/architecture.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="firefox-lockwise-for-ios-architecture">Firefox Lockwise for iOS Architecture</h1>
<h2 id="rxswift">RxSwift</h2>
<p>Firefox Lockwise for iOS makes extensive use of RxSwift, an implementation of the Observable pattern from ReactiveX. More information and many marble diagrams can be found in the <a href="http://reactivex.io/">ReactiveX documentation</a>. The rest of this document relies on a basic understanding of the reader of the ReactiveX-style Observer implementation. Their intro document is a <a href="http://reactivex.io/intro.html">good starting point</a>.</p>
<h2 id="flux">Flux</h2>
<h3 id="architecture-pattern">Architecture Pattern</h3>
<p>In short, Flux architecture design maintains a unidirectional data flow, in which a global Dispatcher receives Actions &amp; dispatches them to appropriate Stores. The Stores, in turn, process data &amp; provide the source of truth for the Views. As users interact with the Views, any updates are made via a dispatched Action and the cycle begins again. See this <a href="https://facebook.github.io/flux/docs/overview.html">flux architecture</a> writeup for more details on the original Flux architecture scheme.</p>
<p>Lockwise implements a modified version of the described architecture (LockFlux), keeping in mind that the original implementation ignores asynchronous work.</p>
<h3 id="memory-management">Memory Management</h3>
<p>The five major components of this architecture (<code>View</code>, <code>Presenter</code>, <code>Store</code>, <code>Dispatcher</code>, and <code>Action</code>) have distinct lifecycle management based on their functions.</p>
<p><code>View</code>/<code>Presenter</code> pairs are allocated and de-allocated as views get displayed or hidden in turn.</p>
<p><code>Store</code>s and the <code>Dispatcher</code> are global singleton objects, meaning that they get lazy-loaded by the application as their shared members get accessed by the <code>Presenter</code>s for view configuration or dispatching.</p>
<p><code>Action</code>s get deallocated as soon as they reach the end observer for their intended function.</p>
<h3 id="viewpresenter">View/Presenter</h3>
<p>All views are bound to a presenter[<a href="#note-1">1</a>]. In this separation, the presenter is responsible for all business logic, and the view is abstracted to a simple protocol. The view is responsible for UIKit-specific configuration and passing user input to its presenter for handling. This allows any complex view-related configuration to be abstracted when dealing with business logic changes, and vice versa. Presenters should never import UIKit in this separation of concerns. The <code>View</code> component of these view-presenter pairs maintains a strong reference to its <code>Presenter</code>, while the <code>Presenter</code> maintains a <code>weak</code> reference to the view to avoid retain cycles under <code>ARC</code>.</p>
<h3 id="action">Action</h3>
<p>Actions are tiny <code>struct</code>s or <code>enum</code>s that contain declarative language about either the triggering user action or the update request for a given <code>Store</code>. They can also pass along small pieces of data in the form of Swift's associated values or the <code>struct</code> properties.</p>
<h3 id="dispatcher">Dispatcher</h3>
<p>The dispatcher class is the simplest in the application; it provides an <code>Action</code>-accepting method as a wrapper for the <code>PublishSubject&lt;Action&gt;</code> that publishes all dispatched actions to interested <code>Stores</code>:</p>
<pre><code>class Dispatcher {
    static let shared = Dispatcher()
    private let storeDispatchSubject = PublishSubject&lt;Action&gt;()

    open var register: Observable&lt;Action&gt; {
        return self.storeDispatchSubject.asObservable()
    }

    open func dispatch(action: Action) {
        self.storeDispatchSubject.onNext(action)
    }
}
</code></pre>

<p>Despite its simplicity, the <code>Dispatcher</code> is a core piece of the LockFlux architecture. Having all user actions pass through the central dispatch allows for easy debugging and telemetry, and enforces agnosticism towards storage on the part of the <code>Presenter</code>, whose only responsibility should be translating application state into view state and communicating user actions.</p>
<h3 id="store">Store</h3>
<p>Stores provide an opaque wrapper around system storage, <code>Replay- /Publish- Subject</code>s, or <code>Relay</code>s for the purposes of data access and view configuration.</p>
<h3 id="view-routing">View Routing</h3>
<p>The special case in this scenario is view routing. To handle the view-changing component of the architecture, there is a <code>RouteStore</code> observed by a <code>RootPresenter</code> that rides along on the back of a <code>RootView</code>. This “containing” view will never be displayed to the user; rather, it will perform the role of listening for navigation-specific <code>Action</code>s &amp; performing the necessary top-level navigation stack swapping or navigation stack manipulation. Routing logic lives entirely separately from individual view configuration logic, allowing for modular view manipulation and easy testing.</p>
<h3 id="example">Example</h3>
<p>To fully understand the concept, it's useful to trace one user action through its lifecycle of use in the app. Following is a simplified description of how the filter field (or search box) on the main item list screen works.</p>
<ol>
<li>When a user enters text into the search field, the textfield binding[<a href="#note-2">2</a>] on the <code>ItemListView</code> emits an event to an observer on the <code>ItemListPresenter</code>.</li>
<li>The <code>ItemListPresenter</code> dispatches a <code>ItemListFilterAction</code>, which is a simple struct with one property - <code>filteringText: String</code>.</li>
<li>The struct does a round trip through the <code>Dispatcher</code> and <code>ItemListDisplayStore</code> before getting combined with the most recent list of items back in the <code>ItemListPresenter</code>.</li>
<li>This combined <code>Observable</code> stream with both the text and the items filters the list of items and maps the filtered list into individual cell configurations.</li>
<li>The view, on receiving the updated / filtered list, re-renders the list of items to only show the ones that the user is searching for.</li>
</ol>
<p>There are a few other listeners for <code>ItemListFilterAction</code>s; for example, the <code>Observable</code> bound to the <code>isHidden</code> property of the Cancel button in the search bar maps the <code>ItemListFilterAction</code> with a simple <code>!isEmpty</code> check -- if the <code>ItemListFilterAction.filteringText</code> is empty, the cancel button is hidden, and if not, it's displayed. While it may seem like a lot of work to make the roundtrip with the <code>Dispatcher</code>, this allows for a number of side benefits. First, it allows for easy manipulation of the text and the displayed items from multiple sources (tapping the clear button as well as editing the text field, for example), and second, routing all user interactions through the <code>Dispatcher</code> allows for low overhead data collection; it's as simple as attaching a listener to the <code>Dispatcher</code>.</p>
<hr />
<p><a name="note-1"/>[1] the name here is pure semantics -- can be thought of as a ViewModel</p>
<p><a name="note-2"/>[2] an <code>Observable</code> stream coming from the <code>RxCocoa</code> bindings for <code>UITextField</code></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../updating_libraries/" class="btn btn-neutral float-right" title="Dependencies">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../install/" class="btn btn-neutral" title="Build and Install"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/mozilla-lockwise/lockwise-ios/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../install/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../updating_libraries/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
